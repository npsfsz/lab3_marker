Lab3:
#Jingfu Wang, 999886066, jingfu.wang@mail.utoronto.ca
#Tao Yuan, 999886002, t.yuan@mail.utoronto.ca


Overview of generateQRcode.c:
Given issuer(the name of the service), accountname(the name of the account), and secret(the 80-bit secret key value, encoded in Base-32), generateQRcode.c is responsible for generating URIs and the associated barcodes for a time-based password (TOTP) and a ticket-based passwords (HOTP). A sample input looks like: ./generateQRcode ECE568 gibson 12345678901234567890

Implementation of validateQRcode.c:
1. Encode issuer and accountname using urlEncode()
2. Check length of secret and add extra 0s
3. Convert secret from hex to int, then encode using base32_encode()
4. Calculate the length of QR string
5. Generate and display URI and barcode for HOTP
6. Generate and display URI and barcode for TOTP

Overview of validateQRcode.c:
Given secret, validateQRcode.c is responsible for verifying whether user provides correct HOTP & TOTP or not.

Implementation of validateQRcode.c:
Verify HOTP value
	1 Generate 8 bytes counter
	2 Convert data type of secret (from string to uint8_t array)
	3 Calculate inner padding and outer padding (inner_padding = (0x36 * Blocksize) XOR secret, outer_padding = (0x5c * Blocksize) XOR secret)
	4 Calculate hmac value (hmac = hash(outer_padding + hash(counter + inner_padding)))
	5 Calculate hotp value (hotp = truncate(hmac))
	6 Compare calculated htop value with user's providing htop value for verifying

Verify TOTP value
	1 Generate time step (30 period)
	2 Convert data type of secret (from string to uint8_t array)
	3 Calculate inner padding and outer padding (inner_padding = (0x36 * Blocksize) XOR secret, outer_padding = (0x5c * Blocksize) XOR secret)
        4 Calculate hmac value (hmac = hash(outer_padding + hash(time_step + inner_padding)))
        5 Calculate hotp value (hotp = truncate(hmac))
        6 Compare calculated htop value with user's providing htop value for verifying
