generateQRcode.c

We simply parse the input strings of issuer, accountName and the secret in hex. Next we pass
the string through the provided urlEncode() to escape any invalid characters. Lastly we passed
the secret through the base32_encode() to convert to base32 to meet the URI spec. However
base32_encode() required a uint8_t which we did manually before passing into the function. The
generated URIs were passed into the provided displayQRcode function to generate the QR code for
use.

validateQRcode.c

We created the HMAC_SHA1() function which is SHA1(K XOR opad, SHA1(K XOR ipad, text)). Where text
is the counter for HOTP and the unix time for TOPT. The key is converted to uint8_t for use in SHA1
and xor'd with the contant values opad for outter padding and ipad for inner padding. Then we used the
sha1_init and update funciton to append the key and text to generate the SHA1. Lastly to generate the
valid token we wrote a truncate() function which takes the HMAC_SHA1 result and follows the doc to
convert it to 6-digit number by calulating the offset (lower 4 bits of string), indexing that value
in the HMAC and modulo it with 10^DIGIT. Also note, the counter and time both have to be 8-bytes as
specified in the documentation.
