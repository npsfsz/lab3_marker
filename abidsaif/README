#saif abid, 999741418, saif.abid@mail.utoronto.ca
#Seyanthan Kumaresan, 999549449, seyan.kumaresan@mail.utoronto.ca 

Part 1:
To generate the QR codes, once the user provides a account name, issuer name and secret
the values are sanitized and the secret is base_32 encoded, the appropriate uri 
is constructed and the displayQR code method is called.

Part 2:
HOTP and TOTP are similar although HOTP is counter based and TOTP is time based.
Even though they have a different "token" for generating their respective HMAC,
the process to generate the HMAC is the same in both. Below I've outlined 
the steps required to compute the HMAC

Steps:
    0. start program and input secret_hex, HOTP HMAC to check and TOTP HMAC to check
    1a. If using TOTP, generate an 8 byte (as a uint8_t array of 8 elements) value, which is based on the current time and the token refresh generate
        When get get the current timestamp, we put it in a var of type long long (64 bits, 8 bytes) so we need to use bit-wise shifting
        to fill the 8 element array. This will be considered as C throghout the rest of the steps
    1b. If using HOTP counter method, generate an 8 byte (as a uint8_t array of 8 elements) value which is your counter. 
        Like, 1a, this value will be considered C throughout the rest of the description.

    2. Take the secret_hex which was inputted and make it into a 64 byte value.
       The first 10 byes will be the actaul secret_hex transformed in binary form.
       The remaining 56 bytes are padded zeros (as per specification). This will be known as K
    3. Generate two arrays, one which we will call ipadXORK which will be the K xord with 0x5c
       repeated for a total fo 64 bytes, and the other which is the opadXORK which is K xored with 0x36
       repeated for a toal of 64 bytes. 
    4. Now we will concat, the ipadXOR with our appropriate C (from step 1) and compute a 
       sha1 hash. This will be known as innerHash.
    5. Now, we concat the opadXORK with our innerHash(from step 4) and compute 
       another 20 byte sha1 hash. we will call this prehmac
    6. A 20 byte hash is a very long value for the client to enter. So, we need to trim this down
       to a smaller value
    7. So, to make this into a shorter value, we will perform what RFC4226 calls "dynamic truncation"
       Which is effectivly a way to bring this 20byte hash into a 4 byte value (32 bits)
    8. Now that we have a 4 byte value(32 bits) we can truncate this number to be a conviniant length
       For our usecase for 2 factor auth, we'll choose a 6 digit number. 
       So, to bring this 4 byte number into a 6 digit number, we'll mod by 1000000
    9. Finally compare your code with this 6 digit number 
    