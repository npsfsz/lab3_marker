#Zach Saltzman, 1000605179, zach.saltzman@mail.utoronto.ca

Generating the QR codes was fairly simple in the given framework. I used a series of simple bit shifts to parse the hex secret into a binary value and used the built-in function to convert it to base 32. Then I created a string according to the format specified in the handout with the values supplied through the command line and used the built-in displayQRcode() function to print the QR code to the screen. 

HOTP and TOTP verification conformed to RFCs 4226 and 6238 respectively. I converted the hex secret to a binary value similar to the first part of the lab and padded it to block length using 54 zeroes. I generated the outer key by XORing each byte of the padded secret with the byte 0x5c and the inner key by XORing with the byte 0x36. The message for HOTP was set to always be the value 1 as specified and the message for TOTP was the number of seconds since the UNIX epoch divided by the default period, 30. I concatenated the key with the inner key and hashed them using SHA-1, then concatenated the result with the outer key and hashed again. To extract a six character value from the 20 byte SHA-1 digest, I used the dynamic truncation procedure detailed in RFC 4226. Namely, I calculated an offset using the lowest 4 bits of the digest, took the 32 bits of the digest starting at that offset, and took the remainder of it with 1,000,000 (i.e. the 32 bits % 1000000) to generate a 6 character OTP. The values generated by this function are then compared against the ones supplied to the function by the command line and the result returned. 
