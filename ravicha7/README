#Rajsimman Ravichandiran, 997477225, rajsimman.ravichandiran@mail.utoronto.ca

Part 1: generateQRcode.c
The first part focuses on creating the HOTP and TOTP values, given the secret key, issuer and the account name.
These are the following steps to create those One-time values:
  1. Encode the Accountname and Issuer values in order to properly encode special characters.
  2. For secret hex, we need to perform a couple of steps:
	a. Convert hex string ("01234") to decimal (two values at a time).
        b. Then, store the char value (of those two values) into a string based array. 
        c. Finally, encode this string using base32_encode() 
  3. After all these values are encoded, we can now create the otpauth://hotp... and otpauth:totp... urls
  4. Once the urls are created, we can display the 2-D barcode for getting the one-time values.

Once the first part is finished, we can either use Google auth app or /util/generateValues code to generate the one-time values. 
Then, we try to validate these values using validateQRcode (part 2). The hardest step from the first part was 2, because of converting the
hex string values into ASCII based values.

Part 2: validateQRcode.c
The second part focuses on validating the HOTP and TOTP values, given the secret key, and those values.
These are the following steps to validate those values:
  1. For HOTP: create an 8 byte array to store the value 1 (for counter).
  2. For TOTP: create an 8 byte array to store the value of T (curr_time - T0/ time_step )
  3. We create the HMAC-SHA-1( secret_hex, counter/period byte array)
  	a. HMAC-SHA-1 = SHA1[ secret_hex XOR OPAD + SHA1(( scret_hex XOR IPAD ) + data) ]
 		i.	data = counter/period byte array
		ii. 	IPAD = 0x36 byte array (of 64 bytes length)
		iii. 	OPAD = 0x5c byte array (of 64 bytes length)
		iv. 	Here again: we convert hex_string (provided as argument) to an int and store that into an array. 
			It allows XORing with IPAD and OPAD.
		v. 	Here I use '+' to represent appending values
  4. The output of HMAC-SHA-1 will be 20 byte value, hence we use Dynamic Truncation to cut it down to 4 bytes.
	a. Get the last byte of the HMAC-SHA-1 output. This represents the offset.
        b. Get the bytes that start from the index that is equal to offset values and get 4 consecutive bytes.
	   I.E., HMAC_OUTPUT[offset],HMAC_OUTPUT[offset+1],HMAC_OUTPUT[offset+2],HMAC_OUTPUT[offset+3]
        c. Mask the MSB of this string (inorder to remove ambiguity between signed vs unsigned operations in different processors)
        d. This gives us 31 bits.
  5. Now, we convert the 31 bits into an integer value and mod it with 10^6 (because we want 6 digits).
  6. This will be the final value we want to compare with the values generated.
  7. If the values are equal, the authentication is successful. If not, the authentication fails.

Final Remarks: This was an interesting lab that provides a basic introduction to multi-factor authentication. I certainly learnt a lot
during the lab. However, I spent a good amount time performing the nuances of converting string to integer and using string arrays and I
felt this new level of complexity is due to th C-language (not because of the content of the lab).
